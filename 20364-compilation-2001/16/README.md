# ממ"ן 16: CPQ פרויקט המהדר #

# מודולים #

1.	Cpq

התכנית הראשית, קוראת ל- yyparse. ומכילה את yylex. בנוסף פותחת קבצים, ובודקת את הממשק.

2.	Cla_tab

המפרש, נבנה ע"י bison. מכיל את yyparse. שקוראת לפונקציות reduce של  reduce ול- yylex לקבלת האסימון הנוכחי.

3.	Lex

(מומש בממ"ן 12) מנתח לקסיקלי הממומש בעזרת מכונת מצבים. מחזיר אסימון אחד כל פעם. yylex של CPQ קוראת ל-lex_nexttoken. מכיל גם את error לטיפול בשגיאות. מאתר מלים שמורות ללא צורך בטבלת הסמלים. שיפור: במקרה של טעויות שכיחות (old fashion token) כמו begin end println מתורגם האסימון למקבילה המתאימה תוך כדי התעלמות מהשגיאה אם מוגדר IGNORE_CMN_ERROR.

4.	Reduce

סכימת התרגום, מטפל (=צמצום) בערכים הסמנטיים של כל משתנה דקדוקי. בסופו של דבר מצומצמת התכנית, אז מועתק הקוד למשתנה הגלובלי progcode לצורת הדפסתו במודול code.

5.	Code

יוצר רביעיות, משחרר אותן בסוף הריצה (אם לא מוגדר MEM_RESERVE – ראה ב"שיקולים") ומדפיס אותן לפי הסדר של progcode לקובץ qud שנוצר ע"י cpq.

6.	Symtbl

טבלת הסמלים/סימבולים/מזהים. מחפש סימבול ע"י  hashing, יוצר כניסה חדשה אם הוא לא קיים ומשחרר את הטבלה. שיפור: כן מאפשרת הטבלה איתור מזהים שלא מאותחלים לפני השימוש בהם או שכלל לא משתמשים בהם אלו. אלו warnings. הטבלה לא כוללת מלים שמורות, וכן כוללת משתנים זמניים.

הקוד ליצירת תוויות ומשתנים זמניים קצר ואינו מצדיק מודול נפרד.

## שיקולים (שלא צויינו ב"מודולים") ## 

1.	קפיצות - כל פעם שנוצר stmt חדש הוא נוסף ל-stmtlist. הקוד יושב בזיכרון. לפני הדפסתו במודולcode  יש מעבר נוסף על הקוד לתרגום תוויות סימבוליות (מהצורה 128 אם זה ה-label ה- 128 שנוצר) למספרי שורות, האחסון התרגום ב-symtbl.

2.	שחרור זיכרון – לפני סוף ריצת cpq כל השטחים שהוקצו ב-heap ע"י malloc משוחררים. אלה כוללים את symtbl והרביעיות quads. שיפור: אמנם מערכת ההפעלה משחררת  שטחים אלו אוטומטית (וכך גם סגירת קבצים) אך מן הראוי לעשות זאת ידנית. עם זאת, בתכניות גדולות, של 8 ק"ב ומעלה, יש להגדיר MEM_RESERVE ב-code.h כדי לחסוך בזיכרון. אחרת אין מספיק מקום ב-heap. לצורך בדיקה שזה הפתרון השתמשתי בתכנית בגודל 10 ק"ב היוצרת 730 הוראות (מתוך 1000 המותרות במפרש qx) ובפונקציה coreleft.

3.	חוצץ קלט – lexbuf מכיל את כל קובץ הקלט. גודלו מוגדר ב-MAX_FILE_LENGTH (כרגע 10 ק"ב). אם הקובץ גדול מדי מופסקת ריצת התכנית.

4.	בדיקות סמנטיות – משולבות בהגדרה מונחית התחביר המתאימה, כך reduce_read בודקת שאכן המזהה קיים, reduce_assign בודקת שאין השמה של float למשתנה מסוג int וכן הלאה.

5.	שגיאות – נערכת החלמה (כמעט) מכל סוג שגיאה. אם יש שגיאה (found_error) לא נוצר קובץ qud. הדבר מבטיח שתיקון כל השגיאות המופיעות בקובץ lst יביא (ברוב המקרים) להצלחת ההידור החוזר.

א.	לקסיקליות – (כתוב lexical error בקובץ .lst) מזהה ארוך מדי מקוצץ, שימוש באותיות גדולות במלה שמורה, שימוש ב-old fashion token, תו לא חוקי.

ב.	סמנטיות – (לא כתוב כלום) כל מה שכתוב בחוברת (עמוד 28), חילוק ב- 0, מספר שלם מעל 32767, שם תכנית לא חוקי.

ג.	תחביריות – (כתוב syntax error) רק אם השגיאה מופיעה ב-stmt כלשהו. שיפור: נעשה שימוש במנגנון ההחלמה משגיאות המובנה ב-bison (האסימון error).

6.	טבלת הסמלים – hashtable של chainlist. חיפוש אסימון לוקח O(N/L) כאשר N מספר סמלים ו-L מספר הכניסות (רצוי ראשוני). ההקצאה דינמית. הפעלת שיטת ה-hashing  (המופיעה בעמוד 436) נותנת תוצאה זהה על כל חברי ה-chainlist באותה כניסה.

א.	הכנסה - כאשר מוצהר משתנה חדש והטיפוס שלו. או כאשר נערך מעבר חוזר על הקוד (לפני הדפסה ב- code_print) לצורך חישוב יעדי קפיצה, אז מוכנס שם התווית ובמקום הטיפוס מספר השורה.

ב.	עדכון – שיפור: כאשר משתנה מאותחל ע"י read או אופרטור ההשמה. או כאשר משתמשים במשתנה (רק ב-expr). העדכון נעשה להדפסת warnings.

שיפור: כאשר מזהה חסר הוא מוכנס לטבלה כדי למנוע הודעת שגיאה חוזרת בכל פעם שהוא מופיע.

7.	מנתח לקסיקלי – אין טבלה במימוש האוטומט. בכל מצב (ע"י switch) בודקים את האות הנוכחית בקלט (if) ומשנים את המצב הנוכחי בהתאם.

א.	מצב 0 מטפל ב-EOF, מזהה לא חוקי

ב.	מצב 1 מטפל באסימון ID

ג.	מצב 2 מטפל במספר מטיפוס int (לפני נקודה עשרונית)

ד.	מצבים 3,4 מטפלים במספר מטיפוס float (בנקודה ואחריה)

ה.	מצב 5 מאחד לצורך חסכון בקוד את הטיפול במספרים (מטיפוס כלשהו)

8.	משתנים זמניים (temp_use/gen) – יש 2 סוגים. ולכן 2 מונים. המבנה הוא _Xnnn כאשר nnn מספר המשתנה (עד 10 מליון) ו-X הסוג (I-int, F-float). נעשה שימוש בקו תחתון כי זה תו שמותר ב-quad אך לא ב-cpl ולכן יש למנוע אפשרות לשימוש במשתנה זהה בשפה. שיפור: לחסכון בסמלים, המונים קטנים או גדלים בהתאם לטכניקת reusing temporary names (עמוד 480), גדלים כאשר נוצר משתנה וקטנים כאשר הוא ארגומנט של הוראה (כמו ב-print, boolexpr).

9.	תוויות (label_gen/put) – עד 9999 תוויות. כיוון שגודל הקובץ עד 32 ק"ב. ההוראה המינימלית היא a is a; שגודלה בצירוף תו שורה חדשה הוא 9 יכולות להיות עד 32000/9 תוויות. מספר זה נכנס ב- 5 תווים. בכל מקרה זה מספר (יחסית) גדול.

10.	שינויים בדקדוק – למיצוי ההפשטה בקוד של reduce ומכיוון ש-bison תומכת בעדיפויות של אסימונים) אין צורך ב- factor/term. לכן expr ממומש פשוט ע"י expr op expr | ID | num. נעשה ויתור על period_token, declarations, type והם שולבו במקום המתאים. כך גם write_stmt, read_stmt, control_stmt שנכנסו ישירות ל-stmt. שיפור: ב- boolexpr נוספה אפשרות לאופרטור and, or (כדי שכתיבת while ((a<b or a=c) and b=d) לא תהיה סיוט).


## פונקציות ראשיות ##

מבנה התיעוד: אין כפילויות בתיאור. דברים שנכתבו כבר יופיעו עם ההתייחסות לסעיף המתאים. כל מודול מכיל מבני נתונים ציבוריים (בקובץ ההצהרה .h), פונקציות פרטיות ומבני נתונים פרטיים (במימוש .c אליהן אי-אפשר לקרוא ממודול אחר) ופונקציות ציבוריות.
בכל מקרה פירוט מלא יהיה בקובץ המקור reduce.c

lex

Token

מכיל lexeme וקוד מתאים המתאר את ה-lexeme

פרטי:

lex_skipspaces – מדלג על רווחים לבנים, מדפיס שורות עם מספרים.

Lex_match(check_lookahead) – בודק מלים שמורות (אחריהן אין אות או מספר אחרת זה מזהה) או סמלים כמו >=, =, } אחריהן מותר תו.

ציבורי:

error(mesg, position) – מדפיס הודעה במיקום הרצוי. מגדיל את found_error

lex_nexttoken – מחזיר את האסימון הבא. 0 אם EOF, ואז yyparse מסיים (מחזיר 1 אם נכשל). שיקול 7.

code

enum של כל ההוראות ב-quad
Quadruple: chainlist של רביעיה והתווית שלה.

פרטי:

quad_item, quads – chainlist של quadruple בזמן יצירתן (כדי להתעלם מהעובדה ש-quadruples גם היא chainlist)

ציבורי:

Code_free – שחרור ה-chainlist, quads הוא ראש הרשימה. (שיקול 2)

code_print(progcode,qud_file) – חישוב יעדי קפיצה (שיקול 1) ואז הדפסה לקובץ. במקרה של קפיצה היעד נלקח מה- symtbl. שיפור: ההדפסה נעשית בהתאם לבלוקים הבסיסיים (יש אינדנטציה לסירוגין).

Code_create(last,label,quadruple) – יוצר אחרי last (אם last קיים, אחרת במקומו) רביעיה חדשה (עם next=0) עם label. מוסיף אותה לרשימה quads.

אחרי כל קריאה ממודול reduce יש לעדכן את code של הערך הסמנטי המתאים.


Symtbl (שיקול 6)

אין מבני נתונים ציבוריים

פרטי:

symtbl_entry – chainlist של lexeme, use, type.
	Symtbl – מערך עם NUMBER_OF_ITEMS symtbl_entries

Symtbl_hash(lexeme) – חישוב הערך המתאים.

ציבורי:

symtbl_free(warn) – שחרור כל הזכרון שהוקצה בהכנסה ב-lookup. שיפור: עכשיו אפשר לבדוק אם יש מזהים שלא השתמשו בהם. אם warn מדפיסים אזהרה. Warn=0 כאשר יש שגיאות (כיוון שלא תמיד יש החלמה משגיאות תחביריות ייתכן שיש משתנים עליהן האזהרה תהיה שגויה).

Symtbl_lookup(lexeme,use,type) – מחזיר type של lexeme אם קיים בכניסת ה-hash המתאימה. אחרת מוכנס. בכל מקרה use מתעדכן לפי הסדר (ז"א קודם אתחול משתנה ורק אח"כ שימוש בו). Lexeme יכול להיות יעד קפיצה (מספר) ואז גם type יהיה מספר.

Cpq – ראה מודול 1

ראוי לפרט קצת על yylex הבנויה ע"פ דרישת yyparse. היא מחזירה קוד אסימון חוקי (זו הדרישה) כך שמדלגים על אסימון  invalid ואת ה-lexeme שלו (רלוונטי למספר, ID ו-relop) בתוך השדה המתאים של yylval. יש לשים לב שהאחרון הוא ערך סמנטי (המוגדר ב-reduce) ולא Token (המוגדר ב-lex).

Reduce

Val:	lexeme – המשתנה עם תוצאת הביטוי, או ה-relop, או ערך המספר, או a/o ל-and/or
	Code – quadruple* לרביעיה הראשונה ב-chainlist של הקוד
	Last – מצביע לרביעיה האחרונה, כך פעולת שרשור תהיה בסיבוכיות O(1)
	Type – מכיל טיפוס הביטוי

פרטי:

temps[2] – מונים למשתנים הזמניים. Temp_gen/use – - שיקול 8
	follow_label – תווית אחרונה שנוצרה.
	Label_number – מונה מספר תוויות שנוצרו.

	Label_gen(dest) – ממיר את label_number לתוך dest
Label_put(val) – שם ב- val.code->label את follow_label ומוחק את follow_label. כל reduce_stmt (לא program, onevar, stmtlist אלא if, while, print…) קורא לה.

Convert(expr,arg) – מוסיף ל-expr.code הוראת itor כאשר arg מושא ההמרה. אם arg מספר מוסיף לו נקודה עשרונית. אם נוצרה itor  יוצרים משתנה זמני חדש, ואם expr.lexeme היה זמני קוראים ל-temp_use.

Code_concat(first, second) – מכניס את second.code ל-first.last ומעדכן את האחרון. לא נמצא במודול code כי אין טעם ש-code "ייראה" את reduce.

ציבורי:

    reduce_progid(lexeme) – מחזיר 1 אם שם התכנית חוקי.
	Reduce_onevar(id,type) – מוסיף ל- symtbl את ההצהרה החדשה
	Reduce_program(stmtlist) – מוסיף halt ומעתיק את stmtlist.code ל-progcode
	Reduce_stmtlist(stmtlist,stmt) – code_concat(stmtlist,stmt)

	Reduce_print(expr) – מדפיס את expr. בהתאם לטיפוס.
Reduce_read(id) – קולט את id. בהתאם לטיפוס.
Reduce_assign(id,expr) – קורא ל-convert אם צריך.

Reduce_expr/boolexpr(expr1,op,expr2) – ראוי לפרט (מעבר לקוד המקור) שע"י ה-lexeme בתוך op בודקים מה תהיה ההוראה. 

והקטע המרתק (עליו ישבתי כמה ימים, למתן סיבוכיות O(1)):

reduce_while – אין כמעט מה לפרט. אם יש follow_label מה-stmt הוא יהיה ל-jump שחוזר לבדיקת התנאי.

Reduce_if – true_Stmt: dummy מייצר jump בכל מקרה. אם יש follow_label אז dummy יצמיד אותו ל-jump, שצריך להיות לשורה לאחר ה-false_stmt. בריצת dummy היעד אינו ידוע כך שרק ב-if הוא נכנס. אם אין follow_label אז dummy יצר כבר את ה-jump הנ"ל.
False_stmt: אם לא קיים (כלומר stmtlist ריק) לא נוצר ה-jump המיותר. אחרת, אם כבר יש תווית היא נלקחת.

## readme ##

disk:

  - contains qx, cpq, (*.prj, *.c, *.h, *.y in \src), and some *.cpl files

  - '\bison' contains bison.

  - '\backup' and '\backup2' contains all the above again.

restrictions: file length < 10 KB. you can change it up to 32 KB

build: (create cpq.exe)

  - cd \src                    | if you want ; in stmtlist (as in course notebook

  - '\bison\bison -d -v cla.y' | run 'swap', then do not run cpq on illegal

  - launch TC 2.01             | cpl programs. like 'if (a=b) {}; else {};;'

  - open cpq.prj               | run 'swap' again to return to ; in stmt


enJoy!       (I'm really was, and almost wrote the code generator)
                           (and flow of control optimizations)

  Shahar.
